#pragma once
/*==============================================================================
Finite impulse response filters.
==============================================================================*/

#include "dspFIRCDiffCoeff.h"
#include "dspFIRFilter.h"

//******************************************************************************
//******************************************************************************
//******************************************************************************

namespace Dsp
{

//******************************************************************************
//******************************************************************************
//******************************************************************************
// FIRFilter, see wikipedia or matlab for definition
// H(z)=B(z)
// Y[n] = B[0]*X[n] + B[1]*X[n-1] + B[2]*X[n-2] + ... + B[N]*X[n-N] 

template <class real_t,int Size>
class FIRCDiff : public FIRFilter<real_t, Size>
{
public:
   typedef FIRFilter<real_t, Size> BaseClass;

   //***************************************************************************
   //***************************************************************************
   //***************************************************************************
   // Constants.

   static const int cN = Size;
   static const int cM = (Size - 1)/2;

   //***************************************************************************
   //***************************************************************************
   //***************************************************************************
   // Members.

   double mCArray[cM + 1];
   double mBArray[cN];

   //***************************************************************************
   //***************************************************************************
   //***************************************************************************
   // Methods.

   // Initialize filter coefficients. 
   void initialize(double aH)
   {
      resetVars();
      for (int i = 0; i < cN; i++) mB[i] = 0;
      doCalcCoeffFirstDerivative_Holob(cN, aH, mCArray, mBArray);
      for (int i = 0; i < cN; i++) mB[i] = (real_t)mBArray[i];
   }
};

//******************************************************************************
//******************************************************************************
//******************************************************************************
}//namespace

