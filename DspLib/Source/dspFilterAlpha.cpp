/*==============================================================================
Description:
==============================================================================*/

//******************************************************************************
//******************************************************************************
//******************************************************************************

#include <stdlib.h>
#include <stdio.h>

#include <math.h>
#include <string.h>

#include "dspFilterAlpha.h"

namespace Dsp
{
namespace Filter
{


//******************************************************************************
//******************************************************************************
//******************************************************************************
//******************************************************************************
//******************************************************************************
//******************************************************************************

   void AlphaOne::initialize(double aP1)
{
   mP1  = aP1;
   mAP1 = 1.0 - aP1;

   mY   = 0.0;
   mXX  = 0.0;
   mK   = 0;
}

//******************************************************************************

double AlphaOne::put(double aY)
{
   mY  = aY;
   mXX = mP1 * aY + mAP1 * mXX;

   mK++;
   return mXX;
}

//******************************************************************************

void AlphaOne::show()
{
   printf("%3d $$ %8.3f %8.3f\n",
      mK,
      mY,
      mXX);
}

//******************************************************************************
//******************************************************************************
//******************************************************************************
//******************************************************************************
//******************************************************************************
//******************************************************************************

void AlphaTwo::initialize(double aP1, double aP2, double aDT)
{
   // X
   mX.initialize(2);
   mTempX1.initialize(2);
   mTempX2.initialize(2);

   // F
   double tFValues[2][2] = {{ (1.0 - aP1), (1.0 - aP1)*aDT },
                            { (-aP2/aDT),  (1.0 - aP2)     }};

   mF.initialize(2,2,&tFValues[0][0]);

   // G
   double tGValues[2] = { aP1, aP2/aDT };

   mG.initialize(2,&tGValues[0]);

   // Reset
   mY=0.0;
   mXX=0.0;
   mXV=0.0;
   mX.reset();
   mK  = 0;
}

//******************************************************************************

void AlphaTwo::put(double aY)
{
   // Store input
   mY = aY;

   // State space calculation
   multiply (mTempX1,mF,mX);

   multiply (mTempX2,mG,aY);

   add (mX,mTempX1,mTempX2);

   // Store outputs
   mXX = mX.e(1);
   mXV = mX.e(2);

   // Done
   mK++;
}

//******************************************************************************

void AlphaTwo::show()
{
   printf("%3d $$ %8.3f %8.3f %8.3f\n",
      mK,
      mY,
      mXX,
      mXV);
}

//******************************************************************************
//******************************************************************************
//******************************************************************************
//******************************************************************************
//******************************************************************************
//******************************************************************************

void AlphaThree::initialize(double aP1,double aP2,double aP3,double aDT)
{
   // X
   mX.initialize(3);
   mTempX1.initialize(3);
   mTempX2.initialize(3);

   // Temps
   double tDT  = aDT;
   double tDT2 = aDT*aDT;
   // F
   double tFValues[3][3] = 
      {{ (1.0 - aP1),       (1.0 - aP1)*tDT, (1.0 - aP1)*tDT2/2.0 },
       { (-aP2/tDT),        (1.0 - aP2),     (1.0 - aP2/2.0)*tDT     },
       { (-aP3/tDT2),       (- aP3/tDT),     (1.0 - aP3/2.0)         }};

   mF.initialize(3,3,&tFValues[0][0]);

   // G
   double tGValues[3] = { aP1, aP2/tDT, aP3/tDT2 };

   mG.initialize(3,&tGValues[0]);

   // Reset
   mY=0.0;
   mXX=0.0;
   mXV=0.0;
   mXA=0.0;
   mX.reset();
   mK  = 0;
}

//******************************************************************************

void AlphaThree::put(double aY)
{
   // Store input
   mY = aY;

   // State space calculation
   multiply (mTempX1,mF,mX);

   multiply (mTempX2,mG,aY);

   add (mX,mTempX1,mTempX2);

   // Store outputs
   mXX = mX.e(1);
   mXV = mX.e(2);
   mXA = mX.e(3);

   // Done
   mK++;
}

//******************************************************************************

void AlphaThree::show()
{
   printf("%3d $$ %8.3f %8.3f %8.3f %8.3f\n",
      mK,
      mY,
      mXX,
      mXV,
      mXA);
}

//******************************************************************************
//******************************************************************************
//******************************************************************************
//******************************************************************************
//******************************************************************************
//******************************************************************************

void PropagatorOne::initialize(double aX0,double aXV,double aDT)
{
   mXX = aX0;
   mDX = aXV*aDT;
}

//******************************************************************************

double PropagatorOne::update()
{
   // Integrate
   mXX += mDX;

   // Done
   mK++;
   return mXX;
}
}//namespace
}//namespace

